# -*- coding: utf-8 -*-
"""NetAlg_PW3_BF_Dijkstra.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12-dQBOkQAYDCqWTqrLRxum-3XnRBzdmZ

# PW3 - BF & Dijkstra Implementation

### Continue of precedent Practical Works (PW1 & PW2) we need to finally apply Bellman-Ford and Dijkstra's algorithm to the same `airports.csv` dataset
"""

import pandas as pd
import networkx as nx
from google.colab import drive
drive.mount('/content/drive')

dataset = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/airports.csv')

G = nx.from_pandas_edgelist(dataset, source="Origin", target="Dest", edge_attr=True, create_using=nx.DiGraph)

dataset.head()

def dijkstra_distance(g,start,final):
    shortest_path = [final]
    dests,predecessors= {},{}
    for vertex in g.nodes():
        dests[vertex] = float("inf")
        predecessors[vertex] = -1
    dests[start] = 0
    for vertex in g.nodes():
        for couple in g.edges():
            if(dests[couple[0]]!=float("inf")) and (dests[couple[0]]+g.edges[couple[0],couple[1]]['Distance']<dests[couple[1]]):
                dests[couple[1]] = dests[couple[0]] + g.edges[couple[0],couple[1]]['Distance']
                predecessors[couple[1]] = couple[0]
    predecessor = predecessors[final]
    while predecessor != start:
        shortest_path.append(predecessor)
        predecessor = predecessors[predecessor]
    shortest_path.append(start)
    
    return dests[final],shortest_path[::-1]



def dijkstra_time(g,start,final):
    shortest_path = [final]
    dests,predecessors= {},{}
    for vertex in g.nodes():
        dests[vertex] = float("inf")
        predecessors[vertex] = -1
    dests[start] = 0
    for vertex in g.nodes():
        for couple in g.edges():
            if(dests[couple[0]]!=float("inf")) and (dests[couple[0]]+g.edges[couple[0],couple[1]]['AirTime']<dests[couple[1]]):
                dests[couple[1]] = dests[couple[0]] + g.edges[couple[0],couple[1]]['AirTime']
                predecessors[couple[1]] = couple[0]
    
    predecessor = predecessors[final]
    while predecessor != start:
        shortest_path.append(predecessor)
        predecessor = predecessors[predecessor]
    shortest_path.append(start)
    
    return dests[final],shortest_path[::-1]



def check_negative_distance_cycle(g,dests):
    for couple in g.edges():
        return ((dests[couple[0]]!=float("inf")) and (dests[couple[0]]+g.edges[couple[0],couple[1]]['Distance']<dests[couple[1]]))



def bellman_ford_distance(g,start,final):
    shortest_path = [final]
    dests,predecessors= {},{}
    for vertex in g.nodes():
        dests[vertex] = float("inf")
        predecessors[vertex] = -1
    dests[start] = 0
    for vertex in g.nodes():
        for couple in g.edges():
            if(dests[couple[0]]!=float("inf")) and (dests[couple[0]]+g.edges[couple[0],couple[1]]['Distance']<dests[couple[1]]):
                dests[couple[1]] = dests[couple[0]] + g.edges[couple[0],couple[1]]['Distance']
                predecessors[couple[1]] = couple[0]
    
    if check_negative_distance_cycle(g,dests):
        print('Negative cycle!')
        return
    predecessor = predecessors[final]
    while predecessor != start:
        shortest_path.append(predecessor)
        predecessor = predecessors[predecessor]
    shortest_path.append(start)
    
    return dests[final],shortest_path[::-1]



def check_negative_time_cycle(g,dests):
    for couple in g.edges():
        return ((dests[couple[0]]!=float("inf")) and (dests[couple[0]]+g.edges[couple[0],couple[1]]['AirTime']<dests[couple[1]]))


        
def bellman_ford_time(g,start,final):
    shortest_path = [final]
    dests,predecessors= {},{}
    for vertex in g.nodes():
        dests[vertex] = float("inf")
        predecessors[vertex] = -1
    dests[start] = 0
    for vertex in g.nodes():
        for couple in g.edges():
            if(dests[couple[0]]!=float("inf")) and (dests[couple[0]]+g.edges[couple[0],couple[1]]['AirTime']<dests[couple[1]]):
                dests[couple[1]] = dests[couple[0]] + g.edges[couple[0],couple[1]]['AirTime']
                predecessors[couple[1]] = couple[0]
    
    if check_negative_time_cycle(g,dests):
        print('Negative cycle!')
        return
    predecessor = predecessors[final]
    while predecessor != start:
        shortest_path.append(predecessor)
        predecessor = predecessors[predecessor]
    shortest_path.append(start)
    
    return dests[final],shortest_path[::-1]

G = nx.from_pandas_edgelist(dataset, source="Origin", target="Dest", edge_attr=True, create_using=nx.DiGraph)


print('Distance and shortest path when using Dijkstra algorithm: \n',dijkstra_distance(G,'BHM','TUS'))

print('Time when using Dijkstra algorithm: \n',dijkstra_time(G,'BHM','TUS'))

print('\n\n')

print('Distance and shortest path when using BF algorithm: \n',bellman_ford_distance(G,'BHM','TUS'))

print('Time when using BF algorithm: \n',bellman_ford_time(G,'BHM','TUS'))